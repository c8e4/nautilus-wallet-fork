<template>
  <div class="flex min-h-full flex-col gap-4 p-4">
    <Card class="p-4 gap-6 flex flex-col">
      <div class="grid gap-1">
        <Input
          v-model.lazy="recipient"
          type="text"
          spellcheck="false"
          placeholder="Recipient"
          class="w-full"
          @blur="v$.recipient.$touch()"
        />
        <div v-if="v$.recipient.$error" class="text-destructive text-xs px-2">
          {{ v$.recipient.$errors[0].$message }}
        </div>
      </div>

      <div class="grid gap-4">
        <AssetInput
          v-for="item in selected"
          :key="item.asset.tokenId"
          v-model="item.amount"
          :asset="item.asset"
          :reserved-amount="getReserveAmountFor(item.asset.tokenId)"
          :min-amount="isErg(item.asset.tokenId) ? minBoxValue : undefined"
          :disposable="!isErg(item.asset.tokenId) || !(isErg(item.asset.tokenId) && isFeeInErg)"
          @remove="remove(item.asset.tokenId)"
        />
      </div>

      <AssetSelector :assets="unselected" @select="add" />
      <p v-if="v$.selected.$error" class="input-error">{{ v$.selected.$errors[0].$message }}</p>
    </Card>

    <div class="flex-grow"></div>

    <fee-selector v-model:selected="feeSettings" :include-min-amount-per-box="!hasChange ? 0 : 1" />
    <Button class="w-full" size="lg" @click="sendTx()">Confirm</Button>
  </div>
</template>

<script lang="ts">
import { defineComponent } from "vue";
import { isEmpty } from "@fleet-sdk/common";
import { useVuelidate } from "@vuelidate/core";
import { helpers, required } from "@vuelidate/validators";
import { BigNumber } from "bignumber.js";
import { differenceBy, remove } from "lodash-es";
import { CheckCheckIcon, ChevronDownIcon } from "lucide-vue-next";
import { useAppStore } from "@/stores/appStore";
import { StateAssetSummary, useWalletStore } from "@/stores/walletStore";
import AssetIcon from "@/components/AssetIcon.vue";
import AssetInput from "@/components/AssetInput.vue";
import AssetSelector from "@/components/AssetSelector.vue";
import DropDown from "@/components/DropDown.vue";
import FeeSelector from "@/components/FeeSelector.vue";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { PopoverTrigger } from "@/components/ui/popover";
import { createP2PTransaction, TxAssetAmount } from "@/chains/ergo/transaction/txBuilder";
import { bn, decimalize, undecimalize } from "@/common/bigNumber";
import { openTransactionSigningModal } from "@/common/componentUtils";
import { useFormat } from "@/composables/useFormat";
import { ERG_DECIMALS, ERG_TOKEN_ID, MIN_BOX_VALUE, SAFE_MIN_FEE_VALUE } from "@/constants/ergo";
import { FeeSettings } from "@/types/internal";
import { validErgoAddress } from "@/validators";

const validations = {
  recipient: {
    required: helpers.withMessage("Receiver address is required.", required),
    validErgoAddress
  },
  selected: {
    required: helpers.withMessage(
      "At least one asset should be selected in order to send a transaction.",
      required
    )
  }
};

export default defineComponent({
  name: "SendView",
  components: {
    AssetInput,
    FeeSelector,
    DropDown,
    ChevronDownIcon,
    CheckCheckIcon,
    AssetIcon,
    Input,
    Card,
    Button,
    AssetSelector,
    PopoverTrigger
  },
  setup() {
    return {
      app: useAppStore(),
      v$: useVuelidate(),
      wallet: useWalletStore(),
      format: useFormat()
    };
  },
  data() {
    return {
      selected: [] as TxAssetAmount[],
      feeSettings: {
        tokenId: ERG_TOKEN_ID,
        value: decimalize(bn(SAFE_MIN_FEE_VALUE), ERG_DECIMALS)
      } as FeeSettings,
      password: "",
      recipient: ""
    };
  },
  computed: {
    unselected() {
      return differenceBy(
        this.wallet.balance,
        this.selected.map((a) => a.asset),
        (a) => a.tokenId
      );
    },
    hasMinErgSelected(): boolean {
      const erg = this.selected.find((x) => this.isErg(x.asset.tokenId));
      if (!erg || !erg.amount || erg.amount.isZero()) {
        return false;
      }

      return undecimalize(erg.amount, ERG_DECIMALS).isGreaterThanOrEqualTo(MIN_BOX_VALUE);
    },
    hasChange(): boolean {
      if (!isEmpty(this.unselected)) {
        return true;
      }

      for (const item of this.selected.filter((a) => a.asset.tokenId !== ERG_TOKEN_ID)) {
        if (
          !item.amount ||
          (!this.isFeeAsset(item.asset.tokenId) &&
            !item.amount.isEqualTo(item.asset.confirmedAmount)) ||
          (this.isFeeAsset(item.asset.tokenId) &&
            !item.amount.isEqualTo(item.asset.confirmedAmount.minus(this.fee)))
        ) {
          return true;
        }
      }

      return false;
    },
    reservedFeeAssetAmount(): BigNumber {
      const feeAsset = this.selected.find((a) => a.asset.tokenId === this.feeSettings.tokenId);
      if (!feeAsset || feeAsset.asset.confirmedAmount.isZero()) return bn(0);
      if (!this.changeValue) return this.fee;
      if (this.feeSettings.tokenId === ERG_TOKEN_ID) return this.fee.plus(this.changeValue);
      return this.fee;
    },
    fee(): BigNumber {
      return this.feeSettings.value;
    },
    isFeeInErg(): boolean {
      return this.isErg(this.feeSettings.tokenId);
    },
    changeValue(): BigNumber | undefined {
      if (!this.hasChange) {
        return;
      }

      return this.minBoxValue;
    },
    minBoxValue(): BigNumber {
      return decimalize(bn(MIN_BOX_VALUE), ERG_DECIMALS);
    },
    devMode(): boolean {
      return this.app.settings.devMode;
    }
  },
  watch: {
    currentWallet() {
      this.$router.push({ name: "assets" });
    },
    assets: {
      immediate: true,
      handler() {
        if (!isEmpty(this.selected) || this.v$.$anyDirty) {
          return;
        }

        this.setErgAsSelected();
      }
    },
    ["feeSettings.tokenId"](newVal: string) {
      if (this.isErg(newVal)) {
        this.setErgAsSelected();
      }
    },
    ["selected.length"]() {
      this.v$.selected.$touch();
    }
  },
  created() {
    if (this.$route.query.recipient && typeof this.$route.query.recipient === "string") {
      this.recipient = this.$route.query.recipient;
    }
  },
  validations() {
    return validations;
  },
  methods: {
    getReserveAmountFor(tokenId: string): BigNumber | undefined {
      if (this.isFeeAsset(tokenId)) {
        return this.reservedFeeAssetAmount;
      } else if (this.isErg(tokenId) && this.hasChange) {
        return this.changeValue;
      }
    },
    async sendTx() {
      const isValid = await this.v$.$validate();
      if (!isValid) {
        return;
      }

      openTransactionSigningModal({
        onTransactionBuild: this.buildTransaction,
        onSuccess: this.clear
      });
    },
    async buildTransaction() {
      return await createP2PTransaction({
        recipientAddress: this.recipient,
        assets: this.selected,
        fee: this.feeSettings,
        walletType: this.wallet.type
      });
    },
    clear(): void {
      this.selected = [];
      this.setErgAsSelected();
      this.recipient = "";
      this.password = "";
      this.v$.$reset();
    },
    setErgAsSelected(): void {
      if (!this.isFeeInErg && !isEmpty(this.selected)) return;

      const selected = this.selected.find((a) => a.asset.tokenId === ERG_TOKEN_ID);
      if (selected) return;

      const erg = this.wallet.balance.find((a) => a.tokenId === ERG_TOKEN_ID);
      if (erg) {
        this.selected.unshift({ asset: erg, amount: undefined });
      }
    },
    add(asset: StateAssetSummary) {
      this.removeDisposableSelections();
      this.selected.push({ asset });

      if (this.feeSettings.tokenId == ERG_TOKEN_ID) {
        this.setMinBoxValue();
      }
    },
    addAll() {
      this.unselected.forEach((unselected) => {
        this.selected.push({ asset: unselected });
      });

      this.setMinBoxValue();
    },
    remove(tokenId: string) {
      remove(this.selected, (a) => a.asset.tokenId === tokenId);
      this.setMinBoxValue();
    },
    setMinBoxValue() {
      if (this.selected.length === 1) return;

      const erg = this.selected.find((a) => this.isFeeAsset(a.asset.tokenId));
      if (!erg) return;

      if (!erg.amount || erg.amount.isLessThan(this.minBoxValue)) {
        erg.amount = bn(this.minBoxValue);
      }
    },
    removeDisposableSelections() {
      if (this.feeSettings.tokenId === ERG_TOKEN_ID) {
        return;
      }

      const first = this.selected[0];
      if (!first) {
        return;
      }

      if (!first.amount || first.amount.isZero()) {
        this.remove(first.asset.tokenId);
      }
    },
    isFeeAsset(tokenId: string): boolean {
      return tokenId === this.feeSettings.tokenId;
    },
    isErg(tokenId: string): boolean {
      return tokenId === ERG_TOKEN_ID;
    }
  }
});
</script>
